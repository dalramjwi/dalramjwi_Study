<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="jsSummary.css" />
  </head>
  <body>
    <div>
      <div class="title">
        <h1>자료형(Data Type)</h1>
        <div class="defi">
          <p>
            : 자료형이란 여러 종류의 데이터를 식별하는 분류이다. 자료형은 해당
            자료형에 대한 값, 명령, 값을 저장하는 방식을 결정한다.
            자바스크립트의 자료형은 크게 기본형(primitive datatype, 원시형)과
            참조형(reference datatype)으로 나뉜다.
          </p>
        </div>
        <div>
          <p class="easy">
            서랍에 옷을 정리할 때 그냥 모든 옷을 다 개서 넣는 것보다 옷 종류에
            따라 분류해서 넣고 꺼내 입는 것이 매우 효율적이다. 옷의 종류를 나눈
            것, 그것이 자료형이다. 이와 같은 관점에서 프로그래밍에서 자료형을
            구분하고 사용하는 것이다.
          </p>
        </div>
        <div><a href="#pri">기본형</a></div>
        <div><a href="#obj">참조형</a></div>
      </div>
      <section id="pri">
        <div>
          <h1>기본형</h1>
          <p class="defi">
            : 기본형, 다시 말해 원시값은 "불변하여 변형할 수 없다."
            <br />원시값은 변수와 다르다. 변수는 새로운 값을 다시 할당할 수
            있지만 이미 생성된 원시값은 재할당으로 변형할 수 없다. <br />또한
            기본형은 변수에 원시값을 할당하면 변수에 값이 저장되며 자료형을 다른
            변수에 할당 시 변수 간 값 복사가 이뤄진다. <br />기본형의 값을
            수정하고 싶다면, 재할당을 통해 수정할 수 있다.
          </p>
          <div class="defi_Ex">
            <p>
              1. 원시값이 불변하다는 이야기는, 메모리 영역과 관련된 이야기이다.
              아래의 예시를 살펴보자.
            </p>
            <p>
              let fruit; // fruit이라는 변수 선언, 식별자를 fruit로 한다.
              <br />fruit = "apple"; // 변수 fruit에 "apple" 을 할당한다.
              <br />이와 같은 과정에서 변수 공간과 값을 저장하는 데이터
              공간에서의 작용이 어떻게 일어나는지에 대해 설명해보겠다.
              <br />아래의 표와 함께 이야기하자면, <br />
              1. 변수를 저장하기 위해 메모리 공간을 확보한다.(@1001) <br />2.
              식별자를 'fruit'으로 한다. <br />3. 저장할 데이터인 'apple'이
              데이터 영역에 있는지 탐색하고 없다면 비어있는 데이터 공간(@5004)에
              저장한다.
            </p>
            <table>
              <tr>
                <th>변수 영역</th>
                <th>주소</th>
                <th>@1001</th>
                <th>@1002</th>
                <th>@1003</th>
                <th>@1004</th>
              </tr>
              <tr>
                <td>-</td>
                <td>데이터</td>
                <td>식별자 : fruit <br />값 :</td>
                <td>-</td>
                <td>-</td>
                <td>-</td>
              </tr>
            </table>
            <table>
              <tr>
                <th>데이터 영역</th>
                <th>주소</th>
                <th>@5003</th>
                <th>@5004</th>
                <th>@5005</th>
                <th>@5006</th>
              </tr>
              <tr>
                <td>-</td>
                <td>데이터</td>
                <td>-</td>
                <td>값 : apple</td>
                <td>-</td>
                <td>-</td>
              </tr>
            </table>
            <p>
              4. 변수 영역에서 식별자 'fruit'을 검색한다.(@1001)
              <br />5. 'apple'의 데이터 영역의 주소(5004)를 변수
              'fruit'(@1001)의 값에 저장한다.
            </p>
            <table>
              <tr>
                <th>변수 영역</th>
                <th>주소</th>
                <th>@1001</th>
                <th>@1002</th>
                <th>@1003</th>
                <th>@1004</th>
              </tr>
              <tr>
                <td>-</td>
                <td>데이터</td>
                <td>식별자 : fruit <br />값 : apple</td>
                <td>-</td>
                <td>-</td>
                <td>-</td>
              </tr>
            </table>
            <p>
              이때, fruit = "grape"를 재할당할 경우 @5004의 값이 변경된다 생각할
              수 있지만, 그것이 아니다.
              <br />여기서 불변성의 개념이 나오는데,
              <span
                >데이터 공간에 저장된 값을 바꿀 수 없기에 새로운 메모리
                공간(@5005)에 할당되고 값이 변경되는 것이다.</span
              >
            </p>
            <table>
              <tr>
                <th>변수 영역</th>
                <th>주소</th>
                <th>@1001</th>
                <th>@1002</th>
                <th>@1003</th>
                <th>@1004</th>
              </tr>
              <tr>
                <td>-</td>
                <td>데이터</td>
                <td>식별자 : fruit <br />값 : <br />@5004 => @5005</td>
                <td>-</td>
                <td>-</td>
                <td>-</td>
              </tr>
            </table>
            <table>
              <tr>
                <th>데이터 영역</th>
                <th>주소</th>
                <th>@5003</th>
                <th>@5004</th>
                <th>@5005</th>
                <th>@5006</th>
              </tr>
              <tr>
                <td>-</td>
                <td>데이터</td>
                <td>-</td>
                <td>값 : apple</td>
                <td>값 : grape</td>
                <td>-</td>
              </tr>
            </table>
          </div>
          <div class="defi_Ex">
            <p>
              2. 원시타입 자료형의 복사는 아래와 같이 이뤄진다.
              <br />let a = 42 ; <br />let b = a ; // => 42 <br />값을 이와 같이
              복사해 할당할 시 값 자체가 복사된다. <br />할당된 변수는 독립적
              존재이다. <br />예를 들어, a의 값을 재할당을 해 5로 바꿨다. b의
              값은 a 이기에 같이 5로 바뀌었다 생각할 수 있지만, 독립적이기에
              42로 나타난다.
            </p>
            <p>
              3. 재할당과 관련해서는, 아래의 예시와 함께 설명하겠다.
              <br />let fruit = "apple"; <br />* 나는 apple 의 값을 grape로
              바꾸고 싶다. <br />그렇다면 재할당을 통해 바꿀 수 있다.
              <br />fruit = "grape"; <br />이때 apple 값이 사라지고 그 자리에
              grape로 덧씌워지는 것이 아닌 apple의 값과 무관하게 grape 값이 새로
              생겨서 그 값으로 할당되는 것이다.
            </p>
          </div>
          <div>
            <p class="easy">
              기본형을 쉽게 설명해보자면 이렇게 비유할 수 있다.
              <br />당신은 마법의 식물을 키우고 있다. 그 식물은 당신이 바라는
              대로 자란다. 그래서 당신은 식물이 수박이 되었으면 좋겠다는 생각을
              한다. 그렇게 수박으로 자라고 있었는데, 어느날 파인애플이 먹고
              싶어서 파인애플로 자라라고 방향을 바꿔준다. <br />여기서 이 마법의
              식물이 수박에서 파인애플로 변환된 과정이 성장 데이터를 수박에서
              파인애플로 덮어씌운 것이 아닌, 수박 데이터는 구석에다 박아두고
              파인애플 데이터를 새로 만들어 적용시켰다는 점이다. <br />이것이
              기본형의 불변성이다. 기본형의 원시값도 이러한 방식으로 재할당이
              이뤄질 때 값이 대체되는 것이 아닌 새롭게 할당되는 것이다.
            </p>
          </div>
        </div>
        <div>
          <div>
            <h2>숫자</h2>
            <p class="defi">
              타 언어처럼 정수형(소수점 無), 실수형(소수점 有) 로 세부적으로
              나누지 않는다.
              <br />일반적인 숫자 외에도 infinity, -infinity, NaN과 같은 특수
              숫자값도 포함한다.
            </p>
            <p class="code">
              <span>var</span> ex ; <br />ex = <span>123</span> ;
            </p>
          </div>
          <div>
            <h2>문자열</h2>
            <p class="defi">
              타 언어처럼 문자형(한 글자)과 문자열로 나누지 않고 통합해 쓴다.
              <br />텍스트 데이터를 나타낸다. <br />작은 따옴표(' '), 큰
              따옴표(" ") 안에 넣어 생성한다.
            </p>
            <p class="code">
              <span>var</span> exx ; <br />exx = <span>'string'</span> ;
            </p>
          </div>
          <div>
            <h2>논리형</h2>
            <p class="defi">
              참(True), 거짓(False) 두개의 값이 존재한다.
              <br />두개의 식을 논리적으로 연산해 True(1), False(0) 값을
              반환한다. <br />빈 문자열, 0, NaN, null, undefined를 False로
              취급한다.
            </p>
          </div>
          <div>
            <h2>undefined형</h2>
            <p class="defi">
              변수명을 선언했으나 변수값을 할당하지 않은 상태 => 메모리 공간만
              확보되고 실제 데이터는 비어있는 상태를 undefined라고 한다.
            </p>
            <p class="code">
              <span>var</span> ex ; <br />
              window.console.log(ex); => undefined
            </p>
          </div>
          <div>
            <h2>null형</h2>
            <p class="defi">
              나중에 할당하기 위해 임의로 비워놓은 상태를 의미한다.
              <br />혹은 의도적으로 변수에 값이 없다는 것을 명시하기 위해 쓴다.
            </p>
            <p class="code">
              <span>var</span> exxx ; <br />exxx = <span>null</span> ; <br />
              window.console.log(exxx); => null
            </p>
          </div>
          <div>
            <h2>symbol</h2>
            <p class="defi">
              다른 값과 중복되지 않는 자료형이다. 변수명의 충돌 없이 사용하기
              위해 활용한다.
            </p>
          </div>
        </div>
      </section>
      <section id="obj">
        <div>
          <h1>참조형</h1>
          <p class="defi">
            : 참조형은 변수에 할당할 때 값을 저장하는 것이 아닌 주소를 저장한다.
            <br />기본형과의 차이점은 변수의 크기가 동적으로 변한다는 것이다.
            참조형은 프로퍼티를 추가, 변경, 삭제가 가능하기에 필요한 메모리
            공간을 예측하기 어렵다. 그렇기에 데이터 자체는 별도의 메모리
            공간(heap)에 저장되고 변수에 할당 시 데이터 주소(heap의 주소값)가
            저장되고 그 주소를 이용해 변수의 값에 접근하는 것이다.
            <br />그렇기에 변수 간에 참조 복사가 이뤄져 같은 객체를 참조할 수
            있게 된다. <br />또한 기본형이 재할당을 통해 수정하는 것과는 달리
            참조형은 객체 자체를 수정할 수 있다.
          </p>
          <div class="defi_Ex">
            <p>
              1. 주소를 저장한다는 이야기가 막연하게 들릴 수 있다. 그렇기에
              예시와 함께 보자. <br />let obj1 = { <br />name : '수현',
              <br />like : '달', <br />}; <br />이처럼 이름(key) : 값(value)로
              이뤄진 프로퍼티로 이뤄진 객체, 참조형 코드가 존재한다.
              <br />이같은 과정에서 저장 과정이 어떻게 일어나는지 설명해보겠다.
              <br />1. 변수 obj1를 저장할 빈 메모리 공간(@1001)을 할당하고
              식별자로 obj1을 저장한다. <br />2. 프로퍼티 집합을 저장하기 위해
              별도의 변수영역(@7001)을 확보하고 이 주소를 데이터 영역의
              공간(@5004)에 저장한다. <br />3. 주소(@7001)를 담고 있는 데이터
              주소(@5004)를 식별자가 obj1인 변수(@1001)의 값에 저장한다.
            </p>
            <table>
              <tr>
                <th>변수 영역</th>
                <th>주소</th>
                <th>@1001</th>
                <th>@1002</th>
                <th>@1003</th>
                <th>@1004</th>
              </tr>
              <tr>
                <td>-</td>
                <td>데이터</td>
                <td>식별자 : obj1 <br />값 : @5004</td>
                <td>-</td>
                <td>-</td>
                <td>-</td>
              </tr>
            </table>
            <table>
              <tr>
                <th>데이터 영역</th>
                <th>주소</th>
                <th>@5003</th>
                <th>@5004</th>
                <th>@5005</th>
                <th>@5006</th>
              </tr>
              <tr>
                <td>-</td>
                <td>데이터</td>
                <td>-</td>
                <td>값 : @7001~</td>
                <td>-</td>
                <td>-</td>
              </tr>
            </table>
            <table>
              <tr>
                <th>@5004의 변수영역</th>
                <th>주소</th>
                <th>@7000</th>
                <th>@7001</th>
                <th>@7002</th>
                <th>@7003</th>
              </tr>
              <tr>
                <td>-</td>
                <td>데이터</td>
                <td>-</td>
                <td>-</td>
                <td>-</td>
                <td>-</td>
              </tr>
            </table>
            <p>
              4. 데이터 주소(@5004)에 확보된 변수영역(@7001, @7002)에 각각
              식별자로 name, like 를 저장한다.
            </p>
            <table>
              <tr>
                <th>@5004의 변수영역</th>
                <th>주소</th>
                <th>@7000</th>
                <th>@7001</th>
                <th>@7002</th>
                <th>@7003</th>
              </tr>
              <tr>
                <td>-</td>
                <td>데이터</td>
                <td>식별자 : name <br />값 :</td>
                <td>식별자 : like <br />값 :</td>
                <td>-</td>
                <td>-</td>
              </tr>
            </table>
            <p>
              5. 식별자가 name인 프로퍼티(@7001)에 할당할 데이터인 '수현'이
              데이터 영역에 있는지 탐색한다. <br />없다면 데이터 영역의
              공간(@5005)에 '수현'을 저장하고 '수현'을 저장한 주소(@5005)를
              프로퍼티(@7001)의 값에 저장한다. <br />마찬가지로, '달'도 똑같은
              수순으로 값을 저장한다.
            </p>
            <table>
              <tr>
                <th>데이터 영역</th>
                <th>주소</th>
                <th>@5003</th>
                <th>@5004</th>
                <th>@5005</th>
                <th>@5006</th>
              </tr>
              <tr>
                <td>-</td>
                <td>데이터</td>
                <td>-</td>
                <td>값 : @7001~</td>
                <td>'수현'</td>
                <td>'달'</td>
              </tr>
            </table>
            <table>
              <tr>
                <th>@5004의 변수영역</th>
                <th>주소</th>
                <th>@7000</th>
                <th>@7001</th>
                <th>@7002</th>
                <th>@7003</th>
              </tr>
              <tr>
                <td>-</td>
                <td>데이터</td>
                <td>식별자: name <br />값 : @5005</td>
                <td>식별자: like <br />값 : @5006</td>
                <td>-</td>
                <td>-</td>
              </tr>
            </table>
          </div>
          <div class="defi_Ex">
            <p>
              2. 기본형과는 달리 재할당 없이 언제든 객체의 내용을 추가, 변경,
              삭제가 가능하다. 또한 내용이 변경되면 객체를 참조하는 모든 요소에
              반영된다.
            </p>
          </div>
          <div>
            <p class="easy">
              참조형을 쉽게 설명해보자면 이렇게 비유할 수 있다.
              <br />어디에서 수정해도 연동되는 노트앱인데, 데이터 자체가
              일차적으로 메모리에 저장되는 것이 아닌 별도의 메모리에 저장되는
              것이다. <br />
              그렇기에 메모리를 열어 노트앱의 정보를 보려 하면 별도의 메모리의
              주소밖에 볼 수 없다.
            </p>
          </div>
        </div>
        <div>
          <div>
            <h2>객체</h2>
            <p class="defi">
              객체란 이름을 갖는 다수의 프로퍼티 집합체이다. <br />프로퍼티란
              이름(key)와 값(value)의 쌍이다. <br />이름(key)에는 문자형이,
              값(value)은 모든 자료형을 표현 할 수 있다. <br />값이 함수 객체를
              참조하면 메서드라 한다. <br />객체의 데이터에 접근하는 방법으로
              두가지 표기법이 쓰인다. <br />1. .(dot) 표기법 - 객체의 이름 뒤
              .을 찍고 key를 적는다 . <br />=> obj1.name // '수현' <br />2.
              [](대괄호) 표기법 - 객체의 이름 뒤 ["key"] 를 적는다. * key가
              문자열인 경우 <br />=> obj1["like"] // '달' <br />2-1. 객체의
              key가 숫자인 경우, . 표기법을 사용할 수 없다. 그렇기에 [] 표기법을
              사용한다. <br />=> obj1[1] // '임시'
            </p>
            <p class="code">
              <span>var</span> like ; <br />like : { <br />time : "night",
              <br />snack : "icecream", }; <br />
              window.console.log(like.snack); // => icecream
            </p>
          </div>
          <h2>배열</h2>
          <p class="defi">
            리스트 같은 객체다. <br />항목 이름이 굳이 필요하지 않는 나열식의
            데이터를 작성할때 사용하려 만든 객체 타입이다. <br />하나의 배열에
            여러 자료형의 데이터를 저장할 수 있다. <br /><span
              >대괄호로 표기한다.</span
            >
            <br />배열의 순서는 0부터 시작한다. 즉, 첫번째의 값을 호출하기
            위해서는 ["0"] 으로 지시해야한다.
          </p>
          <p class="code">
            <span>var</span> namelist ; <br />namelist = ["김수현", "김준혁",
            "한다빈", "류세환"]; <br />
            window.console.log(namelist["0"]); => 김수현
          </p>
          <div>
            <h2>함수</h2>
            <p class="defi">
              자신이 객체이며 다른 객체를 생성할 수 있는 특별한 개체다. 나중에
              추가하기
            </p>
          </div>
        </div>
      </section>
      <div><a href="#">top</a></div>
    </div>
  </body>
</html>
